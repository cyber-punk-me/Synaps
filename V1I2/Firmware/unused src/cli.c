/*
 * cli.c
 *
 *  Created on: 19 нояб. 2017 г.
 *      Author: ai
 */

#include "cli.h"

#include "FreeRTOS.h"
#include "task.h"
#include "FreeRTOS_CLI.h"
#include "cmsis_os.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "usb.h"

#include "firmware_version.h"

#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   1024

//#define cli_STACK_SIZE				( ( unsigned short ) 512 )

static const char * const pcWelcomeMessage =
	"\r\n ______     __  __     __   __     ______     ______   ______    " \
"\r\n/\\  ___\\   /\\ \\_\\ \\   /\\ \"-.\\ \\   /\\  __ \\   /\\  == \\ /\\  ___\\   " \
"\r\n\\ \\___  \\  \\ \\____ \\  \\ \\ \\-.  \\  \\ \\  __ \\  \\ \\  _-/ \\ \\___  \\  " \
"\r\n \\/\\_____\\  \\/\\_____\\  \\ \\_\\\\\"\\_\\  \\ \\_\\ \\_\\  \\ \\_\\    \\/\\_____\\ " \
"\r\n  \\/_____/   \\/_____/   \\/_/ \\/_/   \\/_/\\/_/   \\/_/     \\/_____/ " \
"\r\n                                                                 " \
"\r\nSYNAPS command server started.\r\nType Help to view a list of registered commands.\r\n\0";

void
cliRegisterCommands ( void );

void
cliTaskWorker ( void const * argument )
{

    (void) argument;

    osDelay (3000);

    cliRegisterCommands ();

    //Peripheral_Descriptor_t xConsole;
    int8_t cRxedChar, cInputIndex = 0;

    BaseType_t xMoreDataToFollow;

    /* The input and output buffers are declared static to keep them off the stack. */
    static char pcOutputString[MAX_OUTPUT_LENGTH],
	    pcInputString[MAX_INPUT_LENGTH];

    /* This code assumes the peripheral being used as the console has already
     been opened and configured, and is passed into the task as the task
     parameter.  Cast the task parameter to the correct type. */
    //    xConsole = ( Peripheral_Descriptor_t ) pvParameters;
    /* Send a welcome message to the user knows they are connected. */
    //FreeRTOS_write( xConsole, pcWelcomeMessage, strlen( pcWelcomeMessage ) );
    usb_send_str ((char *) pcWelcomeMessage);

    for ( ;; )
    {
	/* This implementation reads a single character at a time.  Wait in the
	 Blocked state until a character is received. */
	//FreeRTOS_read( xConsole, &cRxedChar, sizeof( cRxedChar ) );
	cRxedChar = usb_get_rx_byte ( portMAX_DELAY);

	if ( cRxedChar == '\r' )
	{
	    /* A newline character was received, so the input command string is
	     complete and can be processed.  Transmit a line separator, just to
	     make the output easier to read. */
	    //FreeRTOS_write( xConsole, "\r\n", strlen( "\r\n" );
	    usb_send_str ("\r\n");

	    /* The command interpreter is called repeatedly until it returns
	     pdFALSE.  See the "Implementing a command" documentation for an
	     exaplanation of why this is. */
	    do
	    {
		/* Send the command string to the command interpreter.  Any
		 output generated by the command interpreter will be placed in the
		 pcOutputString buffer. */
		xMoreDataToFollow = FreeRTOS_CLIProcessCommand (
			pcInputString, /* The command string.*/
			pcOutputString, /* The output buffer. */
			MAX_OUTPUT_LENGTH/* The size of the output buffer. */
			);

		/* Write the output generated by the command interpreter to the
		 console. */
		//FreeRTOS_write( xConsole, pcOutputString, strlen( pcOutputString ) );
		usb_send_str (pcOutputString);

	    }
	    while ( xMoreDataToFollow != pdFALSE );

	    /* All the strings generated by the input command have been sent.
	     Processing of the command is complete.  Clear the input string ready
	     to receive the next command. */
	    cInputIndex = 0;
	    memset (pcInputString, 0x00, MAX_INPUT_LENGTH);
	}
	else
	{
	    /* The if() clause performs the processing after a newline character
	     is received.  This else clause performs the processing if any other
	     character is received. */

	    if ( cRxedChar == '\n' )
	    {
		/* Ignore carriage returns. */
	    }
	    else if ( cRxedChar == '\b' )
	    {
		/* Backspace was pressed.  Erase the last character in the input
		 buffer - if there are any. */
		if ( cInputIndex > 0 )
		{
		    cInputIndex--;
		    pcInputString[cInputIndex] = '\0';
		}
	    }
	    else
	    {
		/* A character was entered.  It was not a new line, backspace
		 or carriage return, so it is accepted as part of the input and
		 placed into the input buffer.  When a \n is entered the complete
		 string will be passed to the command interpreter. */
		if ( cInputIndex < MAX_INPUT_LENGTH )
		{
		    pcInputString[cInputIndex] = cRxedChar;
		    cInputIndex++;
		}
	    }
	}
    }
}

static BaseType_t
prvStartStatTask ( char *pcWriteBuffer, size_t xWriteBufferLen,
		   const char *pcCommandString );
static BaseType_t
prvStopStatTask ( char *pcWriteBuffer, size_t xWriteBufferLen,
		  const char *pcCommandString );

static BaseType_t
prvInfo ( char *pcWriteBuffer, size_t xWriteBufferLen,
	  const char *pcCommandString );

static BaseType_t
prvDemo ( char *pcWriteBuffer, size_t xWriteBufferLen,
	  const char *pcCommandString );

static const CLI_Command_Definition_t xStartStatCommand =
    { "statstart", "statstart: \tStart RTOS statistic task.\r\n\r\n",
	    prvStartStatTask, 0 };

static const CLI_Command_Definition_t xStopStatCommand =
    { "statstop", "statstop: \tStop RTOS statistic task.\r\n\r\n",
	    prvStopStatTask, 0 };

//static const CLI_Command_Definition_t xSetPWMCommand =
//{
//    "setpwm",
//    "setpwm: \tSet PWM value to channel.\r\n\t\tUsage: setpwm channel{1-7} value{0-65535}\r\n\r\n",
//	prvSetPwmToChannel,
//    2
//};

static const CLI_Command_Definition_t xInfoCommand =
    { "info", "info: \tPrint hardware info.\r\n\t\tUsage: info\r\n\r\n",
	    prvInfo, 0 };

static const CLI_Command_Definition_t xDemoCommand =
    { "demo", "demo: \tStart/Stop demo.\r\n\t\tUsage: demo [0-1]\r\n\r\n",
	    prvDemo, 1 };

void
cliRegisterCommands ( void )
{
    FreeRTOS_CLIRegisterCommand (&xInfoCommand);
    FreeRTOS_CLIRegisterCommand (&xDemoCommand);
    FreeRTOS_CLIRegisterCommand (&xStartStatCommand);
    FreeRTOS_CLIRegisterCommand (&xStopStatCommand);
}

static BaseType_t
prvInfo ( char *pcWriteBuffer, size_t xWriteBufferLen,
	  const char *pcCommandString )
{
    (void) pcCommandString;

    char str[1024] =
	{ 0 };

    size_t len = sprintf (
	    str,
	    "\r\nSYNAPS controller. FW:%s\r\nMCU serial: %08lx:%08lx:%08lx\r\n",
	    FIRMWARE_VERSION, STM32_UUID[0], STM32_UUID[1], STM32_UUID[2]);

    str[len++] = '\r';
    str[len++] = '\n';
    str[len++] = 0;

    strncpy (pcWriteBuffer, str, xWriteBufferLen);

    return 0;
}

static BaseType_t
prvStartStatTask ( char *pcWriteBuffer, size_t xWriteBufferLen,
		   const char *pcCommandString )
{
    (void) pcCommandString;

    //PerformanceMetrics_Start( 256UL, tskIDLE_PRIORITY + 1 );

    strncpy (pcWriteBuffer, "RTOS Statistic task started.\r\n\r\n",
	     xWriteBufferLen);

    return 0;
}

static BaseType_t
prvStopStatTask ( char *pcWriteBuffer, size_t xWriteBufferLen,
		  const char *pcCommandString )
{
    (void) pcCommandString;

    //PerformanceMetrics_Stop();

    strncpy (pcWriteBuffer, "RTOS Statistic task stoped.\r\n\r\n",
	     xWriteBufferLen);

    return 0;
}

static BaseType_t
prvDemo ( char *pcWriteBuffer, size_t xWriteBufferLen,
	  const char *pcCommandString )
{
    (void) pcCommandString;

    const char * pdemo;
    BaseType_t demo_lenght;
    uint32_t mode = 0;

    pdemo = FreeRTOS_CLIGetParameter (pcCommandString, 1, &demo_lenght);
    mode = atoi (pdemo);

    char str[100];

    if ( mode == 0 )
    {
//	Debug_Level &= ~DEBUG_PCB_TEST;
	sprintf (str, "Demo mode OFF\r\n\r\n");
    }
    else
    {
//	Debug_Level |= DEBUG_PCB_TEST;
	sprintf (str, "Demo mode ON\r\n\r\n");
    }

    strncpy (pcWriteBuffer, str, xWriteBufferLen);

    return 0;
}

/* [] END OF FILE */
